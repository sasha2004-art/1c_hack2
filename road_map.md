# **Roadmap разработки платформы "Plotix_blog"**

**Технологический стек:**

* **Backend:** FastAPI, PostgreSQL, Docker, Pytest
* **Frontend:** Vue.js (v3, Composition API), Pinia, Vue Router, Docker
* **Общее:** Git, Docker Compose

---

## **Фаза 1: Основа и Аутентификация (Этапы 1-3)**

**Этап 1: Настройка проекта и окружения** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Инициализировать Git-репозиторий.
  * [x] Создать структуру проекта FastAPI.
  * [x] Настроить `Dockerfile` для FastAPI-приложения.
  * [x] Настроить `docker-compose.yml` для запуска FastAPI, PostgreSQL и PGAdmin.
  * [x] Настроить создание таблиц при старте приложения.
* **Frontend (Vue):**
  * [x] Инициализировать проект Vue.js с помощью Vite.
  * [x] Настроить `Dockerfile` для сборки и развертывания Vue-приложения (например, через Nginx).
  * [x] Добавить Vue-сервис в общий `docker-compose.yml`.

**Этап 2: Базовая модель пользователя** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель SQLAlchemy для таблицы `users`.
  * [x] Создать Pydantic-схемы для валидации данных пользователя (`UserCreate`, `UserRead`).
  * [x] Написать базовые Pytest-тесты для проверки конфигурации и подключения к БД.

**Этап 3: Реализация регистрации и авторизации (JWT)** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Реализовать утилиты для хеширования паролей (passlib).
  * [x] Реализовать утилиты для создания и валидации JWT-токенов.
  * [x] Создать эндпоинты: `POST /auth/register` и `POST /auth/token` для входа.
  * [x] Создать защищенный эндпоинт `GET /users/me` для получения данных о текущем пользователе.
  * [x] Написать Pytest-тесты для эндпоинтов регистрации и авторизации.
* **Frontend (Vue):**
  * [x] Настроить Vue Router с базовыми маршрутами (`/login`, `/register`, `/`).
  * [x] Настроить Pinia store для управления состоянием аутентификации (токен, данные пользователя).
  * [x] Создать компоненты страниц `Login.vue` и `Register.vue` с формами.
  * [x] Реализовать логику API-запросов и сохранение токена в localStorage.
  * [x] Настроить навигационные гарды (navigation guards) для защиты роутов.

---

## **Фаза 2: Основной функционал (Этапы 4-7)**

**Этап 4: Управление списками (CRUD)** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель и Pydantic-схемы для `lists` (с полями `type`, `privacy_level`).
  * [x] Реализовать полный CRUD для списков (`/lists`), привязанный к авторизованному пользователю.
  * [x] Написать Pytest-тесты для CRUD операций со списками.
* **Frontend (Vue):**
  * [x] Создать страницу профиля пользователя, где будут отображаться его списки.
  * [x] Создать компонент для отображения карточки одного списка.
  * [x] Реализовать модальное окно или отдельную страницу для создания/редактирования списка (с выбором типа).

**Этап 5: Управление элементами списков (CRUD)** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель и Pydantic-схемы для `items` (с гибким полем `details` типа JSONB).
  * [x] Реализовать CRUD для элементов (`/lists/{list_id}/items`), с валидацией прав доступа.
  * [x] Написать Pytest-тесты для CRUD операций с элементами.
* **Frontend (Vue):**
  * [x] Создать страницу просмотра одного списка (`/lists/{id}`).
  * [x] Реализовать компонент для отображения одного элемента в списке.
  * [x] Создать **динамическую форму** для добавления/редактирования элемента, которая меняет поля в зависимости от типа списка.

**Этап 6: Публичный доступ и кастомизация** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Добавить в модель `lists` поля для кастомизации (`background_url`, `font_family`).
  * [x] Реализовать эндпоинт `GET /public/lists/{public_url_key}` для получения данных списка без авторизации.
  * [x] Дополнить CRUD для списков возможностью редактировать фон и шрифт.
* **Frontend (Vue):**
  * [x] Создать публичную страницу просмотра списка, которая будет отображаться по прямой ссылке.
  * [x] Реализовать отображение кастомного фона и шрифта на странице списка.
  * [x] Добавить в форму редактирования списка поля для загрузки фона и выбора шрифта.

**Этап 7: Реализация бронирования для вишлистов** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель для таблицы `reservations`.
  * [x] Реализовать эндпоинты: `POST /items/{item_id}/reserve` и `DELETE /items/{item_id}/reserve`.
  * [x] Доработать эндпоинт `GET /public/lists/{key}` так, чтобы он для гостей показывал, какие желания забронированы, но скрывал эту информацию от владельца.
* **Frontend (Vue):**
  * [x] На публичной странице вишлиста для гостя отображать кнопку "Забронировать".
  * [x] Реализовать логику, которая помечает забронированные желания (например, делает их неактивными).
  * [x] Убедиться, что владелец списка не видит статус бронирования.

---

## **Фаза 3: Социальные функции и "Вау-эффекты" (Этапы 8-12)**

**Этап 8: Лайки и Комментарии** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модели для таблиц `likes` и `comments`.
  * [x] Реализовать CRUD для комментариев и эндпоинты для лайков.
* **Frontend (Vue):**
  * [x] На странице просмотра элемента (или прямо в карточке) добавить иконку лайка со счетчиком.
  * [x] Реализовать секцию комментариев под каждым элементом.

**Этап 9: Система "Друзья"** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель для таблицы `friendships` (статус: pending, accepted).
  * [x] Реализовать эндпоинты для отправки, принятия, отклонения и удаления запросов в друзья.
* **Frontend (Vue):**
  * [x] Создать страницу "Друзья" со списками друзей и входящих/исходящих заявок.
  * [x] Добавить кнопки "Добавить в друзья" на публичных профилях.

### **Этап 10: Поиск пользователей и перенос желаний** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Реализовать эндпоинт для поиска `GET /users/search`.
  * [x] Реализовать эндпоинт `POST /items/{item_id}/copy` для копирования элемента в свой список.
* **Frontend (Vue):**
  * [x] Создать страницу с поисковой строкой и отображением результатов.
  * [x] На карточках элементов в чужих списках добавить кнопку "Добавить к себе".

### **Этап 11: Лента списков друзей (НОВЫЙ)**

*   **Backend (FastAPI):**
    *   [x] Создать эндпоинт `GET /feed/friends-lists`, который будет агрегировать публичные списки и списки для друзей от пользователей из списка друзей.
*   **Frontend (Vue):**
    *   [x] Создать новую страницу или компонент для отображения ленты списков друзей с пагинацией.

### **Этап 12: Интеграция с API для подбора картинок**

*   **Backend (FastAPI):**
    *   [x] Создать прокси-эндпоинт `GET /utils/image-suggestions?query=...`, который будет делать запрос к внешнему API (например, Unsplash) и возвращать результат.
*   **Frontend (Vue):**
    *   [x] В форме добавления/редактирования желания, при вводе названия, отправлять запрос на бэкенд и отображать предложенные картинки.

---

## **Фаза 4: Геймификация и Удержание (Этапы 13-16)**

### **Этап 13: Трекер привычек и Стрики**

* **Backend (FastAPI):**
  * [ ] Добавить в модель `users` поля `streak_count` и `last_streak_date`.
  * [ ] Реализовать логику обновления стрика при выполнении целевых действий.
  * [ ] Создать CRUD для `daily_goals`.
* **Frontend (Vue):**
  * [ ] В профиле пользователя отображать счетчик стрика.
  * [ ] Реализовать механизм "Дэйли-опросов" для постановки мини-целей.


### **Этап 15: Лента Достижений и Дашборд Друзей**

* **Backend (FastAPI):**
  * [ ] Создать модель для `feed_posts`.
  * [ ] Реализовать эндпоинт `GET /feed` для получения ленты постов от друзей.
* **Frontend (Vue):**
  * [ ] Создать страницу "Лента" (`/feed`).
  * [ ] Реализовать модальное окно для создания поста, которое активирует **только камеру** (с помощью `mediaDevices.getUserMedia`).

### **Этап 16: Финализация, Тестирование и Развертывание**

* **Backend (FastAPI):**
  * [ ] Провести рефакторинг кода.
  * [ ] Увеличить покрытие кода Pytest-тестами до целевого уровня (например, 80%).
  * [ ] Настроить CI/CD для автоматического тестирования и деплоя.
  * [ ] Подготовить production-версию `docker-compose.yml`.
* **Frontend (Vue):**
  * [ ] Провести полный цикл ручного тестирования всех пользовательских сценариев.
  * [ ] Оптимизировать сборку проекта (code splitting, lazy loading).
  * [ ] Провести рефакторинг и финализировать UI/UX.
