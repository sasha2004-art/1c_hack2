# **Roadmap разработки платформы "Plotix_blog"**

**Технологический стек:**

* **Backend:** FastAPI, PostgreSQL, Docker, Pytest
* **Frontend:** Vue.js (v3, Composition API), Pinia, Vue Router, Docker
* **Общее:** Git, Docker Compose

---

## **Фаза 1: Основа и Аутентификация (Этапы 1-3)**

**Этап 1: Настройка проекта и окружения** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Инициализировать Git-репозиторий.
  * [x] Создать структуру проекта FastAPI.
  * [x] Настроить `Dockerfile` для FastAPI-приложения.
  * [x] Настроить `docker-compose.yml` для запуска FastAPI, PostgreSQL и PGAdmin.
  * [x] Настроить создание таблиц при старте приложения.
* **Frontend (Vue):**
  * [x] Инициализировать проект Vue.js с помощью Vite.
  * [x] Настроить `Dockerfile` для сборки и развертывания Vue-приложения (например, через Nginx).
  * [x] Добавить Vue-сервис в общий `docker-compose.yml`.

**Этап 2: Базовая модель пользователя** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель SQLAlchemy для таблицы `users`.
  * [x] Создать Pydantic-схемы для валидации данных пользователя (`UserCreate`, `UserRead`).
  * [x] Написать базовые Pytest-тесты для проверки конфигурации и подключения к БД.

**Этап 3: Реализация регистрации и авторизации (JWT)** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Реализовать утилиты для хеширования паролей (passlib).
  * [x] Реализовать утилиты для создания и валидации JWT-токенов.
  * [x] Создать эндпоинты: `POST /auth/register` и `POST /auth/token` для входа.
  * [x] Создать защищенный эндпоинт `GET /users/me` для получения данных о текущем пользователе.
  * [x] Написать Pytest-тесты для эндпоинтов регистрации и авторизации.
* **Frontend (Vue):**
  * [x] Настроить Vue Router с базовыми маршрутами (`/login`, `/register`, `/`).
  * [x] Настроить Pinia store для управления состоянием аутентификации (токен, данные пользователя).
  * [x] Создать компоненты страниц `Login.vue` и `Register.vue` с формами.
  * [x] Реализовать логику API-запросов и сохранение токена в localStorage.
  * [x] Настроить навигационные гарды (navigation guards) для защиты роутов.

---

## **Фаза 2: Основной функционал (Этапы 4-7)**

**Этап 4: Управление списками (CRUD)** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель и Pydantic-схемы для `lists` (с полями `type`, `privacy_level`).
  * [x] Реализовать полный CRUD для списков (`/lists`), привязанный к авторизованному пользователю.
  * [x] Написать Pytest-тесты для CRUD операций со списками.
* **Frontend (Vue):**
  * [x] Создать страницу профиля пользователя, где будут отображаться его списки.
  * [x] Создать компонент для отображения карточки одного списка.
  * [x] Реализовать модальное окно или отдельную страницу для создания/редактирования списка (с выбором типа).

**Этап 5: Управление элементами списков (CRUD)** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель и Pydantic-схемы для `items` (с гибким полем `details` типа JSONB).
  * [x] Реализовать CRUD для элементов (`/lists/{list_id}/items`), с валидацией прав доступа.
  * [x] Написать Pytest-тесты для CRUD операций с элементами.
* **Frontend (Vue):**
  * [x] Создать страницу просмотра одного списка (`/lists/{id}`).
  * [x] Реализовать компонент для отображения одного элемента в списке.
  * [x] Создать **динамическую форму** для добавления/редактирования элемента, которая меняет поля в зависимости от типа списка.

**Этап 6: Публичный доступ и кастомизация** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Добавить в модель `lists` поля для кастомизации (`background_url`, `font_family`).
  * [x] Реализовать эндпоинт `GET /public/lists/{public_url_key}` для получения данных списка без авторизации.
  * [x] Дополнить CRUD для списков возможностью редактировать фон и шрифт.
* **Frontend (Vue):**
  * [x] Создать публичную страницу просмотра списка, которая будет отображаться по прямой ссылке.
  * [x] Реализовать отображение кастомного фона и шрифта на странице списка.
  * [x] Добавить в форму редактирования списка поля для загрузки фона и выбора шрифта.

**Этап 7: Реализация бронирования для вишлистов** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель для таблицы `reservations`.
  * [x] Реализовать эндпоинты: `POST /items/{item_id}/reserve` и `DELETE /items/{item_id}/reserve`.
  * [x] Доработать эндпоинт `GET /public/lists/{key}` так, чтобы он для гостей показывал, какие желания забронированы, но скрывал эту информацию от владельца.
* **Frontend (Vue):**
  * [x] На публичной странице вишлиста для гостя отображать кнопку "Забронировать".
  * [x] Реализовать логику, которая помечает забронированные желания (например, делает их неактивными).
  * [x] Убедиться, что владелец списка не видит статус бронирования.

---

## **Фаза 3: Социальные функции и "Вау-эффекты" (Этапы 8-12)**

**Этап 8: Лайки и Комментарии** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модели для таблиц `likes` и `comments`.
  * [x] Реализовать CRUD для комментариев и эндпоинты для лайков.
* **Frontend (Vue):**
  * [x] На странице просмотра элемента (или прямо в карточке) добавить иконку лайка со счетчиком.
  * [x] Реализовать секцию комментариев под каждым элементом.

**Этап 9: Система "Друзья"** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Создать модель для таблицы `friendships` (статус: pending, accepted).
  * [x] Реализовать эндпоинты для отправки, принятия, отклонения и удаления запросов в друзья.
* **Frontend (Vue):**
  * [x] Создать страницу "Друзья" со списками друзей и входящих/исходящих заявок.
  * [x] Добавить кнопки "Добавить в друзья" на публичных профилях.

### **Этап 10: Поиск пользователей и перенос желаний** ✅ **ЗАВЕРШЕН**

* **Backend (FastAPI):**
  * [x] Реализовать эндпоинт для поиска `GET /users/search`.
  * [x] Реализовать эндпоинт `POST /items/{item_id}/copy` для копирования элемента в свой список.
* **Frontend (Vue):**
  * [x] Создать страницу с поисковой строкой и отображением результатов.
  * [x] На карточках элементов в чужих списках добавить кнопку "Добавить к себе".

### **Этап 11: Лента списков друзей (НОВЫЙ)**

*   **Backend (FastAPI):**
    *   [x] Создать эндпоинт `GET /feed/friends-lists`, который будет агрегировать публичные списки и списки для друзей от пользователей из списка друзей.
*   **Frontend (Vue):**
    *   [x] Создать новую страницу или компонент для отображения ленты списков друзей с пагинацией.

### **Этап 12: Интеграция с API для подбора картинок**

*   **Backend (FastAPI):**
    *   [x] Создать прокси-эндпоинт `GET /utils/image-suggestions?query=...`, который будет делать запрос к внешнему API (например, Unsplash) и возвращать результат.
*   **Frontend (Vue):**
    *   [x] В форме добавления/редактирования желания, при вводе названия, отправлять запрос на бэкенд и отображать предложенные картинки.

---

## **Фаза 4 (Версия 2.0): Продвинутые Цели и Геймификация**

**Цель фазы:** Внедрить мощную систему отслеживания сложных, измеряемых целей, превратив сервис в персональный трекер достижений.

---

### **Этап 13: Backend - Фундамент для Продвинутых Целей**

*   **Backend (FastAPI):**
    *   [ ] Создать новую модель `GoalTracker` в `models.py`:
        *   `item_id` (ForeignKey к `Item`, one-to-one).
        *   `goal_type` (Enum: `CHECK_IN`, `CUMULATIVE`).
        *   `target_value` (Float, для кумулятивных целей).
        *   `current_value` (Float, default=0).
        *   `target_count` (Integer, для привычек).
        *   `unit_name` (String, напр. "часы", "страниц", "раз").
    *   [ ] Создать новую модель `GoalLog` для записи отдельных сессий прогресса:
        *   `tracker_id` (ForeignKey к `GoalTracker`).
        *   `value_added` (Float, сколько было добавлено).
        *   `logged_at` (DateTime).
    *   [ ] Обновить Pydantic-схему `ItemCreate`, чтобы она могла опционально принимать данные для создания `GoalTracker`.
    *   [ ] Создать новый роутер и эндпоинт `POST /goals/{tracker_id}/log` для записи прогресса.
        *   Тело запроса: `{ "value": float }`.
        *   Логика: находит `GoalTracker`, создает `GoalLog`, обновляет `current_value` в трекере.
        *   **Ключевая интеграция:** Если после обновления `current_value >= target_value`, автоматически вызывать логику выполнения `Item` (установить `is_completed=True`) и обновления стрика (из предыдущего плана).

### **Этап 14: Frontend - Интерфейс Управления Целями**

*   **Frontend (Vue):**
    *   [ ] **Модернизировать `ItemFormModal.vue`:**
        *   Добавить переключатель "Сделать целью с отслеживанием?".
        *   При включении показывать выбор типа цели ("Привычка" или "Прогресс").
        *   В зависимости от выбора, отображать поля для `target_count` или `target_value` и `unit_name`.
    *   [ ] **Создать новый компонент `GoalProgressBar.vue`:**
        *   Принимает на вход данные трекера (`GoalTracker`).
        *   С помощью `v-if` отображает либо круговую диаграмму (для `CHECK_IN`), либо линейный прогресс-бар (для `CUMULATIVE`).
        *   Отображает прогресс в виде "25 / 100 часов" или "10 / 30 ✓".
    *   [ ] **Интегрировать `GoalProgressBar.vue` в `ItemCard.vue`:** он будет отображаться вместо кнопки "Выполнено" для сложных целей.
    *   [ ] **Создать мини-модал `LogProgressModal.vue`:**
        *   Открывается по клику на "+" на `GoalProgressBar.vue`.
        *   Содержит поле для ввода числа (сколько часов/страниц) и кнопку "Записать".
    *   [ ] В `lists.js` (Pinia store) добавить экшен `logGoalProgress(trackerId, value)`, который вызывает новый API эндпоинт и обновляет данные в `currentList` для мгновенного отображения.

### **Этап 15: Визуализация Прогресса и Стрики**

*   **Backend (FastAPI):**
    *   [ ] Реализовать логику стриков, как в предыдущей версии roadmap. Теперь она будет запускаться автоматически при достижении 100% прогресса в `GoalTracker`.
    *   [ ] Доработать эндпоинт `GET /users/me/stats`, чтобы он возвращал не только стрик, но и информацию о текущих активных целях.
*   **Frontend (Vue):**
    *   [ ] На главной странице `Home.vue` или в отдельном дашборде создать секцию "Мои активные цели".
    *   [ ] В этой секции отображать `GoalProgressBar` для всех невыполненных целей с трекерами из разных списков, чтобы пользователь видел весь свой прогресс в одном месте.
    *   [ ] Реализовать компонент для отображения стрика (огненная иконка 🔥 + число).

### **Этап 16: Финализация, Тестирование и UX-полировка**

*   **Backend (FastAPI):**
    *   [ ] Написать Pytest-тесты, покрывающие создание и обновление трекеров, логирование прогресса и автоматическое завершение цели при достижении 100%.
    *   [ ] Проверить обработку некорректных данных (например, попытка записать отрицательное значение).
*   **Frontend (Vue):**
    *   [ ] Протестировать все пользовательские сценарии: создание цели-привычки, цели-прогресса, запись нескольких логов, достижение цели.
    *   [ ] **UX-полировка:** Добавить плавные анимации для заполнения прогресс-баров. Сделать так, чтобы при достижении 100% появлялась красивая анимация или конфетти, даря пользователю чувство удовлетворения.
    *   [ ] Провести финальный UI-аудит, чтобы новые сложные элементы гармонично вписывались в существующий дизайн.