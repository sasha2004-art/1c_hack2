### **Roadmap разработки платформы "Plotix_blog"**

**Технологический стек:**
*   **Backend:** FastAPI, PostgreSQL, Docker, Pytest
*   **Frontend:** Vue.js (v3, Composition API), Pinia, Vue Router, Docker
*   **Общее:** Git, Docker Compose

---

#### **Фаза 1: Основа и Аутентификация (Этапы 1-3)**

**Этап 1: Настройка проекта и окружения** ✅ **ЗАВЕРШЕН**
*   **Backend (FastAPI):**
    *   [x] Инициализировать Git-репозиторий.
    *   [x] Создать структуру проекта FastAPI.
    *   [x] Настроить `Dockerfile` для FastAPI-приложения.
    *   [x] Настроить `docker-compose.yml` для запуска FastAPI, PostgreSQL и PGAdmin.
    *   [x] Настроить создание таблиц при старте приложения.
*   **Frontend (Vue):**
    *   [x] Инициализировать проект Vue.js с помощью Vite.
    *   [x] Настроить `Dockerfile` для сборки и развертывания Vue-приложения (например, через Nginx).
    *   [x] Добавить Vue-сервис в общий `docker-compose.yml`.

**Этап 2: Базовая модель пользователя** ✅ **ЗАВЕРШЕН**
*   **Backend (FastAPI):**
    *   [x] Создать модель SQLAlchemy для таблицы `users`.
    *   [x] Создать Pydantic-схемы для валидации данных пользователя (`UserCreate`, `UserRead`).
    *   [x] Написать базовые Pytest-тесты для проверки конфигурации и подключения к БД.

**Этап 3: Реализация регистрации и авторизации (JWT)** ✅ **ЗАВЕРШЕН**
*   **Backend (FastAPI):**
    *   [x] Реализовать утилиты для хеширования паролей (passlib).
    *   [x] Реализовать утилиты для создания и валидации JWT-токенов.
    *   [x] Создать эндпоинты: `POST /auth/register` и `POST /auth/token` для входа.
    *   [x] Создать защищенный эндпоинт `GET /users/me` для получения данных о текущем пользователе.
    *   [x] Написать Pytest-тесты для эндпоинтов регистрации и авторизации.
*   **Frontend (Vue):**
    *   [x] Настроить Vue Router с базовыми маршрутами (`/login`, `/register`, `/`).
    *   [x] Настроить Pinia store для управления состоянием аутентификации (токен, данные пользователя).
    *   [x] Создать компоненты страниц `Login.vue` и `Register.vue` с формами.
    *   [x] Реализовать логику API-запросов и сохранение токена в localStorage.
    *   [x] Настроить навигационные гарды (navigation guards) для защиты роутов.

---

#### **Фаза 2: Основной функционал (Этапы 4-7)**

**Этап 4: Управление списками (CRUD)**
*   **Backend (FastAPI):**
    *   [ ] Создать модель и Pydantic-схемы для `lists` (с полями `type`, `privacy_level`).
    *   [ ] Реализовать полный CRUD для списков (`/lists`), привязанный к авторизованному пользователю.
    *   [ ] Написать Pytest-тесты для CRUD операций со списками.
*   **Frontend (Vue):**
    *   [ ] Создать страницу профиля пользователя, где будут отображаться его списки.
    *   [ ] Создать компонент для отображения карточки одного списка.
    *   [ ] Реализовать модальное окно или отдельную страницу для создания/редактирования списка (с выбором типа).

**Этап 5: Управление элементами списков (CRUD)**
*   **Backend (FastAPI):**
    *   [ ] Создать модель и Pydantic-схемы для `items` (с гибким полем `details` типа JSONB).
    *   [ ] Реализовать CRUD для элементов (`/lists/{list_id}/items`), с валидацией прав доступа.
    *   [ ] Написать Pytest-тесты для CRUD операций с элементами.
*   **Frontend (Vue):**
    *   [ ] Создать страницу просмотра одного списка (`/lists/{id}`).
    *   [ ] Реализовать компонент для отображения одного элемента в списке.
    *   [ ] Создать **динамическую форму** для добавления/редактирования элемента, которая меняет поля в зависимости от типа списка.

**Этап 6: Публичный доступ и кастомизация**
*   **Backend (FastAPI):**
    *   [ ] Добавить в модель `lists` поля для кастомизации (`background_url`, `font_family`).
    *   [ ] Реализовать эндпоинт `GET /public/lists/{public_url_key}` для получения данных списка без авторизации.
    *   [ ] Дополнить CRUD для списков возможностью редактировать фон и шрифт.
*   **Frontend (Vue):**
    *   [ ] Создать публичную страницу просмотра списка, которая будет отображаться по прямой ссылке.
    *   [ ] Реализовать отображение кастомного фона и шрифта на странице списка.
    *   [ ] Добавить в форму редактирования списка поля для загрузки фона и выбора шрифта.

**Этап 7: Реализация бронирования для вишлистов**
*   **Backend (FastAPI):**
    *   [ ] Создать модель для таблицы `reservations`.
    *   [ ] Реализовать эндпоинты: `POST /items/{item_id}/reserve` и `DELETE /items/{item_id}/reserve`.
    *   [ ] Доработать эндпоинт `GET /public/lists/{key}` так, чтобы он для гостей показывал, какие желания забронированы, но скрывал эту информацию от владельца.
*   **Frontend (Vue):**
    *   [ ] На публичной странице вишлиста для гостя отображать кнопку "Забронировать".
    *   [ ] Реализовать логику, которая помечает забронированные желания (например, делает их неактивными).
    *   [ ] Убедиться, что владелец списка не видит статус бронирования.

---

#### **Фаза 3: Социальные функции и "Вау-эффекты" (Этапы 8-11)**

**Этап 8: Лайки и Комментарии**
*   **Backend (FastAPI):**
    *   [ ] Создать модели для таблиц `likes` и `comments`.
    *   [ ] Реализовать CRUD для комментариев и эндпоинты для лайков.
*   **Frontend (Vue):**
    *   [ ] На странице просмотра элемента (или прямо в карточке) добавить иконку лайка со счетчиком.
    *   [ ] Реализовать секцию комментариев под каждым элементом.

**Этап 9: Система "Друзья"**
*   **Backend (FastAPI):**
    *   [ ] Создать модель для таблицы `friendships` (статус: pending, accepted).
    *   [ ] Реализовать эндпоинты для отправки, принятия, отклонения и удаления запросов в друзья.
*   **Frontend (Vue):**
    *   [ ] Создать страницу "Друзья" со списками друзей и входящих/исходящих заявок.
    *   [ ] Добавить кнопки "Добавить в друзья" на публичных профилях.

**Этап 10: Поиск и перенос желаний**
*   **Backend (FastAPI):**
    *   [ ] Реализовать эндпоинт для поиска `GET /search/lists` (MVP: по названию).
    *   [ ] Реализовать эндпоинт `POST /items/{item_id}/copy` для копирования элемента в свой список.
*   **Frontend (Vue):**
    *   [ ] Создать страницу с поисковой строкой и отображением результатов.
    *   [ ] На карточках элементов в чужих списках добавить кнопку "Добавить к себе".

**Этап 11: Интеграция с API для подбора картинок**
*   **Backend (FastAPI):**
    *   [ ] Создать прокси-эндпоинт `GET /utils/image-suggestions?query=...`, который будет делать запрос к внешнему API (например, Unsplash) и возвращать результат.
*   **Frontend (Vue):**
    *   [ ] В форме добавления/редактирования желания, при вводе названия, отправлять запрос на бэкенд и отображать предложенные картинки.

---

#### **Фаза 4: Геймификация и Удержание (Этапы 12-15)**

**Этап 12: Трекер привычек и Стрики**
*   **Backend (FastAPI):**
    *   [ ] Добавить в модель `users` поля `streak_count` и `last_streak_date`.
    *   [ ] Реализовать логику обновления стрика при выполнении целевых действий.
    *   [ ] Создать CRUD для `daily_goals`.
*   **Frontend (Vue):**
    *   [ ] В профиле пользователя отображать счетчик стрика.
    *   [ ] Реализовать механизм "Дэйли-опросов" для постановки мини-целей.

**Этап 13: Виртуальный Питомец**
*   **Backend (FastAPI):**
    *   [ ] Добавить в модель `users` поле `pet_xp`.
    *   [ ] Реализовать сервис, который начисляет XP за выполнение целей.
*   **Frontend (Vue):**
    *   [ ] В профиле пользователя создать компонент для отображения питомца.
    *   [ ] Реализовать смену изображений питомца в зависимости от количества XP.

**Этап 14: Лента Достижений и Дашборд Друзей**
*   **Backend (FastAPI):**
    *   [ ] Создать модель для `feed_posts`.
    *   [ ] Реализовать эндпоинт для создания поста в ленте (с загрузкой фото).
    *   [ ] Реализовать эндпоинт `GET /feed` для получения ленты постов от друзей.
    *   [ ] Реализовать эндпоинт `GET /dashboard/friends-progress` для расчета и отдачи статистики по друзьям.
*   **Frontend (Vue):**
    *   [ ] Создать страницу "Лента" (`/feed`).
    *   [ ] Реализовать модальное окно для создания поста, которое активирует **только камеру** (с помощью `mediaDevices.getUserMedia`).
    *   [ ] Создать страницу "Прогресс друзей" (`/dashboard`).

**Этап 15: Финализация, Тестирование и Развертывание**
*   **Backend (FastAPI):**
    *   [ ] Провести рефакторинг кода.
    *   [ ] Увеличить покрытие кода Pytest-тестами до целевого уровня (например, 80%).
    *   [ ] Настроить CI/CD для автоматического тестирования и деплоя.
    *   [ ] Подготовить production-версию `docker-compose.yml`.
*   **Frontend (Vue):**
    *   [ ] Провести полный цикл ручного тестирования всех пользовательских сценариев.
    *   [ ] Оптимизировать сборку проекта (code splitting, lazy loading).
    *   [ ] Провести рефакторинг и финализировать UI/UX.